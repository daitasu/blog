---
title: "勉強会[GraphQL入門]"
date: 2018-02-10T11:37:32+09:00
tags: ["勉強会","会社紹介","GraphQL","クエリ言語"]
categories: ["藤井 大祐(daitasu)"]
---

<br>

みなさんこんにちは、パーソルプロセスアンドテクノロジー株式会社のAS統括部、daitasuです。<br>
今回も毎週の勉強会の様子を発信していきます！<br>
<br>
また、技術的なブログについては現在Qiitaの方に移行しております。<br>
<br>
テクテクチームのメンバーが各々に書き進めていますのでこちらもぜひご覧ください。<br>
<br>
[Qiita - パーソルプロセス&テクノロジー](https://qiita.com/organizations/persol-pt)<br>
<br>

<br>
さて、今週の発表者はサーバエンジニアである[ビトルさん](https://persol-pt.github.io/categories/%E3%83%93%E3%83%88%E3%83%AB/)。<br>
<br>
テーマは **「GraphQL入門」** でした。<br>
<br>
<br>

### 2018年2月8日の勉強会　
### テーマ「GraphQL入門」
---

<br>

{{< figure src="/images/tech-workshop/20180208/20180208-01.jpg" title="" >}}<br>

<br>
今回のお話では、ここ数年話題に上がっていたFacebookによって開発された<br>
クエリ言語、「GraphQL」をご紹介いただきました。<br>
<br>
<br>
GraphQLはよくRESTfulと比較されることが良くありますが、<br>
そういった話も織り交ぜながら、今回は実際にビトルさんが触ってみて感じたこと、<br>
利点や課題点についての説明でした。<br>
<br>
<br>
### GraphQLの特徴
* APIの定義にあたるのがSchema
* クエリ言語なので対象のDBなどのデータストレージは何でもいい
* バージョンレスAPI
* 多数のプログラミング言語で利用できる

特徴としては、上記のようなお話がありました。<br>
<br>
ここからは実際の処理を見ていきます。<br>
<br>
<br>

### GraphQLの処理
<br>

{{< figure src="/images/tech-workshop/20180208/20180208-02.png" title="" >}}<br>

<br>

GraphQLでは上記のようにSchemaを定義していきます。<br>
例では、Shopというオブジェクト型を定義し、<br>
idとnameフィールドを定義しています。<br>
<br>
GraphQLはこのように、Schemaの存在と問い合わせ言語仕様がセットになっており、<br>
型システムに基づいたAPIの構築ができます。<br>
<br>
上記の例のように、ID型は一意性を保証します。<br>
また、Not Nullは**!**で示すそうです。<br>
<br>
次に、検索クエリです。<br>
こちらはSchemaの中にQuery型として定義するそうです。<br>
は以下のように示すそうです。<br>

```
schema {
    type shop{
        id: ID!
        name: String!
    }

    type Query {
        shops: [Shop]!
        shop(name: String): Shop
    }
}
```

このように引数付きのフィールドを定義することで、<br>
検索クエリを作れます。<br>
<br>
クエリの書き方は以下のような感じです。<br>

```
query {
    shop (name: "バナナ屋")　{
        name
    }
}
```

また、RESTと比較される部分の一つに、<br>
必要なフィールドだけを取得できるという点があるようです。<br>
<br>
REST APIでは、求めるリソースについてのすべてのフィールドが返ってきます。<br>
idで検索をかけても、nameでかけてもidとnameが含まれたオブジェクトの配列が<br>
返されるといった形ですね。<br>
<br>
ですが、GraphQLではnameだけといった取得を簡単に行えるようです。<br>

```
query {
    shops {
        name
    }
}
```

上記にidも足すと、idも返ってくる、というようにフィールド名の有無だけで<br>
取得するフィールドを決定できます。<br>
<br>
<br>
### データ操作
<br><br>
先ほどのようにSchemaにMutationという型を定義することで、<br>
データの追加や変更といった操作も行うことができます。<br>
<br>
<br>

{{< figure src="/images/tech-workshop/20180208/20180208-03.png" title="" >}}<br>

<br>
<br>

### 良かった点・課題点
<br>
今回実際にビトルさんが触ってみた感想として、<br>
以下のようなことをお話頂きました。<br>
<br>
【良かった点】<br>

* 動詞やURIなどのHTTP構造に頼らない
* 直感的でわかりやすい問い合わせ言語と型システムの層を載せている
* クライアント毎に必要な情報を個別のクエリとしてリクエストできる
* 1回のリクエストでいくつでもリソースを取得できる
* レスポンスを自由にカスタマイズできる

<br>
【課題点】<br>

* HTTPのメソッドやステータスコードによる挙動の予測ができなくなる<br>
　　queryとmutationだけだとGETとPOSTしかない状態に等しい<br>
　　削除、追加、更新なのか判断しづらくなる
* 上記の理由によってREST APIに比べてドキュメントが作成しづらい
* 1回のリクエストでいくつでもリソースを取得できる反面、データの数によってはサーバーのリソースを必要以上に消費するリスクがある

<br>
【感想】<br>

* RDBには向かない<br>
　　大量のレコード同士をjoinしたクエリを簡単に書けるため、DBにすぐ負荷をかけてしまう
* MongoDBなどのNoSQL系DBと相性は良さそう<br>
　　ただ、バックエンドのコード側でDB用のスキーマも定義しないといけない、二重に手間がかかる。<br>
　　DB側がある程度サポートしてくれると使うのが楽になるかも
* SQLみたいに共通レイヤーになりきれていない印象
* フロントエンドから取得するデータの形式が頻繁に変わるようなサービスだと向いているかも<br>
　　ただし、データ構造の設計などは従来のRESTと同様にちゃんと意識してやらないといけない

<br>
まだまだ課題が多いところもあるようですが、<br>
HTTP構造に頼らないことや1回のリクエストでいくつでもリソースの取得ができる点など<br>
RESTとの使い分けを明確に行えば多くのメリットがありそうです！<br>
<br><br>
それでは、また来週！
<br><br><br><br>