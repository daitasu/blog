---
title: "勉強会[GOのパフォーマンスチューニング]"
date: 2018-04-26T10:50:30+09:00
tags: ["勉強会","会社紹介","golang","パフォーマンスチューニング", "アルゴリズム"]
categories: ["藤井 大祐(daitasu)"]
---

<br>

みなさんこんにちは、<br>
パーソルプロセスアンドテクノロジー株式会社のEP統括部、daitasuです。<br><br>
<br>
今週も私たちの部の勉強会の様子をお送りいたします。<br>
<br>
※技術的なブログについてはQiitaでメンバーが各々に書き進めています。<br>
こちらもぜひご覧ください。<br>
<br>
[Qiita - パーソルプロセス&テクノロジー](https://qiita.com/organizations/persol-pt)<br>
<br>

さて、今週の発表者はGoをこよなく愛する[nissy](https://github.com/nissy)さん。<br>
テーマは「GOのパフォーマンスチューニング」です。<br>
<br>
<br>

## テーマ「GOのパフォーマンスチューニング」
---

{{< figure src="/images/tech-workshop/20180406/20180406-01.jpg" title="" >}}<br>

<br>

今回はGOのオープンソースに定期的に貢献しているnissyさんが、<br>
「Goのイケてるコードを見せてくれ！」と言われて作成した<br>
Go言語がいかに素晴らしいかを語るGoのパフォーマンスチューニングの話でした。<br>
<br>
私はまだプログラミング歴2年目でGoもCも触ったことがないため、<br>
メモリ管理などはあまり詳しいことは分からないのですが、<br>
分かった範囲で調べて掘り下げてみました。<br>
<br>
<br>

## slice/array
---
<br>

{{< figure src="/images/tech-workshop/20180406/20180406-02.png" title="slice/array" >}}<br>

<br>

ここでは、Go言語のarrayとsliceの違い、それぞれの書き方での<br>
パフォーマンスの差を比較していました。<br>
<br>
Go言語のSliceはほかの言語のArrayに似ているけれど、少し違う部分があるようですね。<br>
<br>
Array型は配列の長さを作成時に指定しますが、Sliceでは要素の型のみを記載し、<br>
長さの記載はしません。<br>
<br>
そのため、上記のようにfor文で繰り返していくと、<br>

* slice ・・・ その都度新しくメモリを確保していく<br>
* array ・・・ 必要分のメモリを先に確保し、そこに文字を入れていく<br>

<br>
といった動きになります。<br>
そのため、arrayの方が処理速度は速くなりますが、<br>
要素数を指定しないといけないので、使いどころが難しく、<br>
柔軟性ではsliceが長けている、といった感じですかね。<br>
<br>
このあたりにslice/arrayの違いは書かれていたので、そこからも学んでみました。<br>
[参考サイト](http://dibtp.hateblo.jp/entry/2014/07/06/190804)
<br>
<br>
<br>

## match
---
<br>

{{< figure src="/images/tech-workshop/20180406/20180406-03.png" title="match" >}}<br>

<br>
こちらは正規表現の話です。<br>
Go言語の正規表現はThompson NFA と呼ばれる実装をしているそうです。<br>
NFA？とは？？と社会人2年目の私はまだまだ勉強不足のためこちらも調べました。<br>
<br>
NFAとは"非決定性有限オートマトン"とのことです。<br>
さらに難しくなりました。<br>
<br>
有限オートマトンというのは、あるインプットがあった際に、<br>
その真偽値を出す機会です。<br>
<br>
よく状態遷移図で書き表され、内部に有限個の状態を保持しており、<br>
何かしらの入力がある度に状態を変化していく、といった流れです。<br>
<br>
この辺に詳しく書いてありました。<br>
[参考サイト](https://codezine.jp/article/detail/3039?p=3)<br>
<br>
<br>
上記の例では、3番目が一番高いベンチマークを取っています。<br>
これは正規表現を使わない例ですね。<br>
<br>
正規表現を使った場合、オートマトンの状態も逐次更新しないと行けないため、<br>
使わないでいいなら使わないほうが早い！<br>
ということですね。<br>
<br>
<br>

## 文字連結
---

{{< figure src="/images/tech-workshop/20180406/20180406-05.png" title="文字連結" >}}<br>

<br>

こちらはJavaでいうStringクラスとStringBufferクラスの違いと<br>
だいたい一緒です。<br>
String型は不変オブジェクトのため、一度初期化されると内容の変更はできません。<br>
<br>
上記のようにStringに **+=** をかけると、新たにメモリが確保され、<br>
新規の文字列オブジェクトを生成します。<br>
<br>
そのため、2番目の例のように先にString型のメモリを確保して<br>
追加していくほうが速くなるというわけですね。<br>
<br>
3番目の例は
ASCIIコードを使い、後でキャストを行うという、少し裏ワザチック？なやり方のようでした。<br>
<br>
<br>
<br>

## sync.Pool
---

{{< figure src="/images/tech-workshop/20180406/20180406-06.png" title="sync.Pool" >}}<br>

<br>

最後はメモリプール機構の話です。<br>
先に最大数必要となるであろう、メモリの箱を用意しておき、<br>
その確保したメモリ領域のみを用いてメモリにデータを割り当てていくやり方です。<br>
<br>
Cに触れたことがないので詳しく語れませんが、<br>
CやC++のようにガベージコレクションを持たない言語は<br>
メモリの開放を自動でやってくれないので、開発者が自分で組み込む必要があります。<br>
<br>
そのため、解放できてなかったー！といったメモリリーク問題を<br>
防ぐ手法の一つにメモリプールがあります。<br>
<br>
<br>
今回お話頂いた例では、<br>
下側がメモリプールを使っており、そのため繰り返し数が増減しようと<br>
ベンチマークは変わらず不変となるようです。<br>
<br>
そのため、要素数が少ない分には<br>
makeを利用して回した方が効率がいいようですね。<br>
<br>
<br>

## まとめ
---
<br>
最後に、nissyさんは以下のようにまとめていました。<br>
* チューニングの前にアルゴリズムを見直そう
* メモリの割り当てとか解放とかのGCが走るのがパフォーマンスに大きく影響するので意識する
* 非同期処理も軽い処理だと逆に遅い
* channelは結構コスト高い
* reflectダメ、絶対

<br>
今回の話を聞いて、自分もGo言語学んでみたくなりました。<br>
システムプログラミングでアルゴリズムを深く理解できれば、<br>
サービスのパフォーマンス改善の取り組みにも<br>
より熱が入っていきそうですね。<br>
<br>
<br>
[nissy](https://github.com/nissy)さん、ありがとうございました。<br>

<br><br><br>